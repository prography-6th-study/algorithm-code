# 개념 정리
1. 해시
2. 스택, 큐
3. 힙
4. 정렬
5. 완전탐색
6. 탐욕법
7. DP
8. 깊이/너비 우선 탐색
9. 이분탐색
10. 그래프

## 해시
- 연관배열 구조를 이용하여 키에 결과 값(value)을 저장하는 자료구조이다.
- {key : value} 형태로 이루어져 있다.
- 파이썬에서는 딕셔너리 자료형이 이에 해당하고 key는 고유한 값을 가진다.
- 저장 단계의 시간 복잡도는 O(1)이다. 삭제 단계도 역시 O(1)이다. 키는 고유하며 해당 키와 매칭되는 값을 찾아서 삭제하면 되기 때문. 탐색 단계에서도 역시 O(1)이다. 해당 key에 매칭되는 value를 찾으면 되기 때문.
- 순서가 있는 배열에는 어울리지 않는다. 키를 가지고 빠르게 value에 접근하고, 조작할 수 있는 장점이 있어서 많이 사용된다.set

    #### set은 dictionay를 구현한 클래스이다.
    set 은 순서가 없는 중복이 불가능한 collection 자료형이다. 주로 item 테스트, 중복제거 등에 사용되고 교집합, 합집합, 차집합 등을 수학적인 계산이 가능하다. 다른 collection 자료형 처럼 item 검사, 길이, 루프가 가능하다. set 은 삽입된 item 의 위치를 저장하지 않기 때문에 item 간의 순서가 없다. 따라서 indexing 이 불가능하고, 자르기가 안되고, 그외의 sequential 한 작업이 불가하다. set 은 dictionary 를 구현한 클래스인데, dictionary 의 key 가 set 의 item 이 된다. 그렇기 때문에 set 은 dictionary 나 list 처럼 중복되는 요소를 담을 수 없다.

## 스택
- 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 Last In First Out 형식의 자료 구조. 즉, 가장 최근에 추가한 항목이 가장 먼저 제거 된다.
- 실행 취소 등에서 사용 된다.
- dfs알고리즘에서 사용된다.
- 파이썬에서는 쓰는 list는 스택 구조이다.

## 큐
- 먼저 집어 넣은 데이터가 먼저 나오는 자료구조. First In First Out
- 선입선출이 필요한 대기열 등에서 사용된다.
- 파이썬에서는 `from queue import Queue` 를 통해 큐를 사용할 수 있고, 앞 뒤 모두 pop이 가능한 `from collections import deque` 도 있다.

## 힙 Heap
- 개념
  - 여러 개의 값들 중에서 최솟값 또는 최댓값을 빠르게 찾기 위해 만들어진 자료구조
  - 완전 이진 트리의 일종

- 노드 삽입
  - 가장 마지막 위치에 삽입한다
  - 부모와 위치를 교환하면서 자신의 위치를 찾아 나간다.

- 루트 노드 삭제
  - 가장 마지막 노드를 루트 노드로 올린다.
  - 자식과 비교하면서 위치를 변경해 나간다.

- 파이썬에서 사용하는 법
  ```python
  import heapq
  
  list = []
  heapq.heappush(list, 3)
  heapq.heappop(list)
  
  # 기존 리스트를 힙으로 변환
  heapq.heapify(list)
  ```

## 정렬
- 버블 정렬
  - 인접한 두 요소를 비교하면서 정렬해 나가는 방법
  - 시간 복잡도는 항상 O(N^2)
- 삽입 정렬
  - 이미 정렬이 된 부분에서 자신의 위치를 찾아 삽입하는 방법
  - 최선의 경우 O(N), 최악의 경우 O(N^2)
- 선택 정렬
  - 정렬되지 않은 부분에서 최솟값을 찾아 정렬된 부분 제일 끝에 추가하는 방법
  - 항상 O(N^2)
- 합병 정렬
  - 배열을 두 개로 나누고 합병할 때 정렬하는 방법
  - 합병할 때, 두 개의 리스트를 비교하면서 더 작은 값을 임시 배열에 넣어주면서 정렬
  - 임시 배열을 필요로 한다.
  - 항상 O(nlogN)
- 퀵 정렬
  - 하나의 pivot을 정하고 그 값보다 작으면 왼쪽에 위치시키고 크면 오른쪽에 위치시킨다.
  - 최악의 경우 O(N^2), 평균 O(nlogN)

## 완전탐색 (Brute-Force)
- 모든 경우의 수를 다 해보는 방법
- 알고리즘을 만들기 쉽다.
- 시간이 오래 걸린다.


## 그리디 Greedy
- 각 단계에서 가장 최선의 선택을 하는 방법
- 각 단계에서 최선의 선택을 한 것이 전체적으로도 최선이길 바라는 알고리즘
- 거스름돈 문제가 가장 대표적이다.